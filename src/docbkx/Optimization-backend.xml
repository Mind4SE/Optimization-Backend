<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book[
<!ENTITY % myents SYSTEM "./shared.ent" >
%myents;
]>
<book status="draft" xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en">
  <info>
    <title><emphasis>&productName;</emphasis> Guide</title>
    <revhistory>
      <revision>
        <revnumber>0.1</revnumber>
        <date>2014-02-21</date>
        <author>
          <personname>
            <firstname>Yves</firstname>
            <surname>TEISSIER</surname>
          </personname>
        </author>
        <revremark>First revision of <emphasis>&productName;</emphasis> Guide</revremark>
      </revision>
      <revision>
        <revnumber>0.2</revnumber>
        <date>2014-03-13</date>
        <author>
          <personname>
            <firstname>Stéphane</firstname>
            <surname>SEYVOZ</surname>
          </personname>
        </author>
        <revremark>Document review</revremark>
      </revision>
      <revision>
        <revnumber>0.3</revnumber>
        <date>2014-03-21</date>
        <author>
          <personname>
            <firstname>Yves</firstname>
            <surname>TEISSIER</surname>
          </personname>
        </author>
        <revremark>Add @Single annotation, add detailed schema for @StaticDefinitionsBindingsList
          and @FreezeCallPointer</revremark>
      </revision>
      <revision>
        <revnumber>0.4</revnumber>
        <date>2014-03-24</date>
        <author>
          <personname>
            <firstname>Julien</firstname>
            <surname>TOUS</surname>
          </personname>
        </author>
        <revremark>Document review : modify @Singleton (gain) and mention unused factory
          elimination</revremark>
      </revision>
      <revision>
        <revnumber>0.5</revnumber>
        <date>2014-03-24</date>
        <author>
          <personname>
            <firstname>Yves</firstname>
            <surname>TEISSIER</surname>
          </personname>
        </author>
        <revremark>Add synthesis section, add generalization of the @StaticBindings annotation to
          collections</revremark>
      </revision>
      <revision>
        <revnumber>0.6</revnumber>
        <date>2014-06-03</date>
        <author>
          <personname>
            <firstname>Yves</firstname>
            <surname>TEISSIER</surname>
          </personname>
        </author>
        <revremark>Add gain table</revremark>
      </revision>
      <revision>
        <revnumber>0.7</revnumber>
        <date>2014-07-09</date>
        <author>
          <personname>
            <firstname>Stéphane</firstname>
            <surname>SEYVOZ</surname>
          </personname>
        </author>
        <revremark>Removed all @Single-related references (deprecated)</revremark>
      </revision>
      <revision>
        <revnumber>0.8</revnumber>
        <date>2014-10-02</date>
        <author>
          <personname>
            <firstname>François</firstname>
            <surname>DELOYE</surname>
          </personname>
        </author>
        <revremark>Typos fixes and document rework to include parts in Mindc and plugins User
          Guide</revremark>
      </revision>
    </revhistory>
  </info>
  
  <chapter>
    <title>Introduction</title>
    <section>
      <title>Aim of this document</title>
      <para>This document introduces the <emphasis>&productName;</emphasis> features.</para>
      <para>It is targeted for developers who wish to benefit of optimized code generated by the
        Mindc compiler such as memory footprint (Flash and RAM) reduction and performance
        improvement).</para>
      <para>This document refers to advanced concepts of Mind language and Mindc compiler, for
        details, refer to Mindc and plugins User Guide</para>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="sections/Optimization-backend_aim.xml"/>
  </chapter>
  <chapter>
    <title>Overview</title>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="sections/Optimization-backend_usage.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="sections/Optimization-backend_annotations.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="sections/Optimization-backend_DSS.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="sections/Optimization-backend_gains.xml"/>

    <simplesect>
      <title/>
      <example>
        <title><code>@Static</code> gain</title>
        
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/AtStaticGain.svg" format="SVG" width="80%"/>
          </imageobject>
        </mediaobject>
      </example>
      
      <example>
        <title><code>@StaticBindings</code> gain</title>
        
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/AtStaticBindingsGain.svg" format="SVG" width="80%"/>
          </imageobject>
        </mediaobject>
      </example>
    </simplesect>
  </chapter>
  
  <chapter>
    <title>Details</title>
    <section xml:id="optim-annot-static">
      <title>
        <code>@Static</code>
      </title>

      <simplesect>
        <title>Annotation fields</title>
        <para>No field</para>
      </simplesect>

      <simplesect>
        <title>Annotation targets</title>
        <para>
          <simplelist type="inline">
            <member>Binding</member>
          </simplelist>
        </para>
        <para>This annotation is used for a binding definition.</para>
        <para>The <code>@Static</code> annotation means that the methods calls for the binding are
          replaced by direct calls between the client and server interfaces.</para>
        
        <note>
          <para>This annotation is also applicable if the interfaces are part of interface
            collections.</para>
        </note>
        
        <example>
          <title><code>@Static</code> overview</title>
          
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="images/AtStatic.png" format="PNG" width="80%"/>
            </imageobject>
          </mediaobject>
        </example>
      </simplesect>
      
      <simplesect>
        <title>Usage condition</title>

        <para>The component that requires the client interface and the component that provides the
          server interface must be both <code>@Singleton</code>.</para>

        <para>If one of them is not a <code>@Singleton</code> than the <code>@Static</code>
          annotation has no effect and a warning is generated at the compilation time.</para>
      </simplesect>

      <simplesect>
        <title>Consequences</title>

        <para>The binding between client A and server B cannot be removed.</para>

        <para>Another client A' still has the possibility to be dynamically
        bound to the server B.</para>

        <para>The interface on B still can be discovered</para>
      </simplesect>

      <simplesect>
        <title>Gains</title>

        <para>This annotation mainly reduces the call time between a client
        and a server interface.</para>

        <para>It also reduces memory data use on the client side.</para>
      </simplesect>

      <simplesect>
        <title>Example</title>

        <para>The <code>@Static</code> annotation is described in the file
        <filename>optimisation/staticbinding/StaticBindingApplication.adl</filename></para>

        <para>The binding between the client interface of the component <code>bootStrap</code> and
          the server interface of the component <code>SingletonComponent</code> is
            <code>@Static</code>.</para>

        <example>
          <title>The <code>@Static</code> annotation</title>

          <programlisting language="adl" linenumbering="unnumbered"><xi:include href="../../mindc-optimizations/src/assemble/resources/examples/optimisations/static/src/main/mind/staticbinding/StaticBindingApplication.adl" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>
        </example>
      </simplesect>
    </section>

    <section xml:id="optim-annot-StaticBindings">
      <title>
        <code>@StaticBindings</code>
      </title>

      <simplesect>
        <title>Annotation fields</title>

        <para>
            <command>@StaticBindings ( <replaceable>true</replaceable> | <replaceable>false</replaceable> )</command>
        </para>

        <para>This option allows to propagate the annotation in all sub-composites, by default,
          option is set to <code>false</code>.</para>
      </simplesect>

      <simplesect>
        <title>Annotation targets</title>

        <para>
          <simplelist type="inline">
            <member>Composite definition</member>
          </simplelist>
        </para>
        <para>This annotation is used for a <code>@Singleton</code> composite definition.</para>
      <para>The <code>@StaticBindings</code> annotation means that all bindings in a
            <code>@Singleton</code> composite are <code>@Static</code>, thus they are not
          reconfigurable.</para>

      <note>
        <para>This annotation is applicable also on interfaces collections.</para>
      </note>

      <note>
        <para>Equivalent to the generalization of the <code>@Static</code> annotation for all
            bindings inside the composite, all data structures on the server interfaces side are
            also removed.</para>
      </note>

      <note>
        <para>If there is no attribute
            <!--Does the presence of attribute reduce the optimization benefit ??? attributes are not really glue.-->,
            no controller and no sub-components then all the "glue" is removed.</para>
      </note>

      <note>
        <para>If several instances of a component are absolutely mandatory, a
              <code>@Singleton</code> inherited component can be used instead in the
              <code>@StaticBindings</code>composite (see example below for details)</para>
      </note>

      <example>
        <title><code>@StaticBindings</code> overview</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/AtStaticBindings.png" format="PNG" width="80%"/>
          </imageobject>
        </mediaobject>
      </example>
      </simplesect>

      <simplesect>
        <title>Usage condition</title>

        <para>All sub-components must be <code>@Singleton</code>.</para>

        <para>A single instance of the components is a mandatory pre-condition for
            <code>@StaticBindings</code>, that allowing very strong assumptions during code
          generation.</para>

        <para><?oxy_comment_start author="SESA258801" timestamp="20141013T143244+0200" comment="Vrai aussi pour @Static ?"?>Any
          reconfiguration using BIND_MY_INTERFACE or Fractal controllers is not possible and
          strictly forbidden. Compilation will fail otherwise. Warning: No incompatibility
          verification is done yet.<?oxy_comment_end?></para>
      </simplesect>

      <simplesect>
        <title>Consequences</title>

        <para>No dynamic binding is possible for the selected composite.</para>
      </simplesect>

      <simplesect>
        <title>Gains</title>

        <para>This annotation reduces the application memory footprint and reduces the call time
          between sub-components.</para>
        <para>Interface data structures are removed on both client and server sides.</para>

        <para>Since the memory footprint gain is a fix value per entity, if the user code size is
          small, the gain ratio will be high.</para>
      </simplesect>

      <simplesect>
        <title>Remarks (March 2014, 19th)</title>
        <para><?oxy_comment_start author="SESA258801" timestamp="20141013T160654+0200" comment="Quel est le status sur les ift collections, les controllers"?>Bindings
          with source or destination collection interfaces are NOT supported in the previous
          releases, as well as bindings leading to controllers: They are tolerated but never
          optimized.</para>
        <para>Next compiler releases will support collections optimization both as binding source or
          destination. This should speed up execution with collections, hopefully gain in data
          sections, but can (to this day) sometimes result in data section growth. Keep in touch
          with the Mind team for further information (development in
          progress).<?oxy_comment_end?></para>
      </simplesect>

      <simplesect>
        <title>Example</title>

        <para>This example illustrates the usage of the <code>@StaticBindings</code>
          annotation.</para>

        <para>All bindings in the composite <code>StaticBindingsApplication</code> are
          static.</para>
        <para>To be able to use the multi-instantiated <code>MultiInstanciableComponent</code>
          component, a <code>@Singleton</code> inherited anonymous component is used instead.</para>

        <example>
          <title>The <code>@StaticBindings</code> annotation</title>
          <programlisting language="adl" linenumbering="unnumbered"><xi:include href="../../mindc-optimizations/src/assemble/resources/examples/optimisations/static-bindings/src/main/mind/staticbindings/StaticBindingsApplication.adl" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>
        </example>
      </simplesect>
    </section>

    <section xml:id="optim-annot-StaticDefinitionsBindingsList">
      <title>
        <code>@StaticDefinitionsBindingsList</code>
      </title>
      
      <simplesect>
        <title>Annotation fields</title>
        <para>
          <command>@StaticDefinitionsBindingsList ( { @StaticDefinitionBinding(fromItf =
          "<replaceable>&lt;component definition.client interface></replaceable>", toItf =
          "<replaceable>&lt;component definition.server interface></replaceable>"), ... } )</command>
        </para>
      </simplesect>
      
      <simplesect>
        <title>Annotation targets</title>
        
        <para>
          <simplelist type="inline">
            <member>Composite definition</member>
          </simplelist>
        </para>


      <para>The <code>@StaticDefinitionsBindingsList</code> annotation is aimed to optimize the
          bindings between one or severacd l client interface of a component to a server interface of a
          component definition.</para>

      <para>Function call is « frozen » for the specified unique target definition (no other) at
          compilation time :</para>

      <itemizedlist>
      <listitem>
        <para>The call function is blocked on a component definition.</para>
      </listitem>

      <listitem>
        <para>The server component type can be instantiated several time in the composite.</para>
      </listitem>
      </itemizedlist>

      <example>
        <title><code>@StaticDefinitionsBindingsList</code> overview</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/AtStaticDefinitionsBindingsList.png" format="PNG" width="80%"/>
          </imageobject>
        </mediaobject>
      </example>

      <example>
        <title><code>@StaticDefinitionsBindingsList</code> detail</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/AtStaticDefinitionsBindingsList-02.png" format="PNG" width="80%"/>
          </imageobject>
        </mediaobject>
      </example>
      </simplesect>
      
      <simplesect>
        <title>Usage condition</title>

        <para>The client component and the server component <emphasis role="bold">are not</emphasis>
          necessarily <code>@Singleton</code>.</para>

        <para>Neither server interface collection nor client interface collection are supported with
          this optimization.</para>
      </simplesect>

      <simplesect>
        <title>Consequences</title>

        <para>It is possible to change the binding with <code>BIND_MY_INTERFACE</code>, but only
          with components of the specified server definition type. Components from other definitions
          cannot be bound.</para>
      </simplesect>

      <simplesect>
        <title>Remark</title>

        <para>If <code>CALL_PTR</code> is used as thread-safe and lock-free alternative to
            <code>BIND_MY_INTERFACE</code> for highly-dynamic binding, it is not optimized with
            <code>@StaticDefinitionsBindingsList</code> annotation but with
            <code>@FreezeCallPointer</code> annotation (see below).</para>
      </simplesect>

      <simplesect>
        <title>Gains</title>

        <para>This annotation reduces the call time and keeps partial flexibility. It is useful for
          intensive calls to large pools of components of the same definition type.</para>
      </simplesect>

      <simplesect>
        <title>Example</title>

        <example>
          <title>The <code>@StaticDefinitionsBindingsList</code> annotation</title>

          <programlisting language="adl" linenumbering="unnumbered"><xi:include href="../../mindc-optimizations/src/assemble/resources/examples/optimisations/static-definition-binding/src/main/mind/staticdefinitionbinding/StaticDefinitionBindingApp.adl" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>
        </example>
      </simplesect>
    </section>

    <section xml:id="optim-annot-FreezeCallPointer">
      <title>
        <code>@FreezeCallPointer</code>
      </title>

      <simplesect>
        <title>Annotation fields</title>
        <para>
          <command>@FreezeCallPointer ( toItf = "<replaceable>&lt;component definition.server
              interface></replaceable>" )</command>
        </para>
      </simplesect>

      <simplesect>
        <title>Annotation targets</title>

        <para>
          <simplelist type="inline">
            <member>Primitive definition</member>
          </simplelist>
        </para>


      <para>The <code>@FreezeCallPointer</code> annotation optimizes the  <code>CALL_PTR</code>
          invocations.</para>
        <para>Its objective is the same as the <code>@StaticDefinitionsBindingsList</code>
          annotation, but it optimizes the <code>CALL_PTR</code> (that is thread-safe and
          lock-free), while calling a pool of target component instances (restricted to the same
          target definition, like <code>@StaticDefinitionsBindingsList</code>). </para>
        <para>It is appropriate to used this annotation with components already using the
            <code>@UseIDL</code> annotation. </para>

      <example>
        <title><code>@FreezeCallPointer</code> overview</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/AtFreezeCallPointer.png" format="PNG" width="80%"/>
          </imageobject>
        </mediaobject>
      </example>

      <example>
        <title><code>@FreezeCallPointer</code> detail</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/AtFreezeCallPointer-02.png" format="PNG" width="80%"/>
          </imageobject>
        </mediaobject>
      </example>
      </simplesect> 
      <simplesect>
        <title>Usage condition</title>

        <para>No declaration of the server interface in the client ADL
        component.</para>
      </simplesect>

      <simplesect>
        <title>Consequences</title>

        <para>The client interface cannot be bound to components interfaces from another server
          definition.</para>

        <para><code>CALL_PTR</code> can target only the specific interface of components from the
          type (definition) specified in the annotation argument, and no other, in the whole scope
          of the component.</para>

        
        <note><para>Usage of <code>CALL_PTR</code> is not advised since it does not show the corresponding
            interface binding in the architecture diagram.</para></note>
        
      </simplesect>

      <simplesect>
        <title>Gains</title>

        <para>The call time is reduced by calling directly the server interface.</para>

        <para>This optimization is an alternative to <code>@StaticDefinitionsBindingsList</code> for
          intensive calls to large pools of components of the same type (definition). </para>
        <para>With <code>@StaticDefinitionsBindingsList</code>, the <code>BIND_MY_INTERFACE</code>
          macro is used to choose the target of the calls, and then the <code>CALL</code> macro is
          used. With <code>FreezeCallPointer</code>, only the <code>CALL_PTR</code> is used, there
          is not need to use <code>BIND_MY_INTERFACE</code> macro. As <code>BIND_MY_INTERFACE</code>
          has an effect on a variable (stateful action), multi-threaded applications may face
          troubles during this action. As <code>CALL_PTR</code> is stateless, safe and lock-free
          multi-threading is possible within the component while targeting different
          components.</para>
      </simplesect>

      <simplesect>
        <title>Example</title>

        <example>
          <title>The <code>@FreezeCallPointer</code> annotation</title>

          <programlisting language="adl" linenumbering="unnumbered">import fractal.api.Factory;
import fractal.api.Component;
import fractal.api.AttributeController;

/**
 * This component is calling a "Service" interface implementation 
 * from a pointer, using the CALL_PTR macro. 
 * This is not an optimisation, but a declaration. 
 */
@UseIDL("singlestaticcallptr.factory.selfcall.Service")

/**
 * Hard-write the CALL_PTR in the component to
 * target interface instance ("s") from definition
 * type ("singlestaticcallptr.factory.selfcall.Server")
 * the instances can be different though: the optimization
 * just replaces the function call
 */
@FreezeCallPointer(toItf="singlestaticcallptr.factory.selfcall.Server.s")

primitive singlestaticcallptr.factory.selfcall.Client {
  provides Main as entryPoint;
  requires optional Component as compCtrl;
  requires optional AttributeController as attrCtrl;
  requires optional GetServicePointer as getServicePtrItf;
  requires Factory as f;
  source client.c;
}</programlisting>
        </example>
      </simplesect>
    </section>
</chapter>
  <appendix>
    <title>Other useful annotations</title>
    
    <section xml:id="optim-annot-singleton">
      <title>
        <code>@Singleton</code>
      </title>
      
      <simplesect>
        <title>Annotation fields</title>
        
        <para>No field</para>
      </simplesect>
      
      <simplesect>
        <title>Annotation targets</title>
        
        <para>
          <simplelist type="inline">
            <member>Any component definition</member>
          </simplelist>
        </para>
 
      <para>The <code>@Singleton</code> annotation specifies that the definition is instantiated
          only one single time in a given application. An error is reported by the Mind compiler if
          a definition with this annotation is instantiated more that once in an application.</para>
      
      <note>
        <para>Composite definitions that contain at least one singleton sub-component are implicitly
            declared singleton. A warning is raised in this case. It is recommended to add
            explicitly the <code>@Singleton</code> annotation on such a composite definition.</para>
      </note>
      
      <note>
        <para><?oxy_comment_start author="SESA258801" timestamp="20141014T151027+0200" comment="Je ne comprends pas"?>Instantiating
            a generic definition by passing a <code>@Singleton</code> definition as value results in
            a singleton definition<?oxy_comment_end?>.</para>
      </note>
      
      <example>
        <title><code>@Singleton</code> overview</title>
        
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/AtSingleton.png" format="PNG" width="80%"/>
          </imageobject>
        </mediaobject>
      </example>
      </simplesect>
      <simplesect>
        <title>Usage condition</title>
        
        <para>No condition</para>
      </simplesect>
      
      <simplesect>
        <title>Consequences</title>
        
        <para>The annotated component cannot be instantiated several times.</para>
        
        <note>
          <para>Since the component is unique, some assumptions can be done and optimizations such
            as <code>@Static</code> or <code>@StaticBindings</code> can be applied.</para>
        </note>
        <note>
          <para>To call Mind interface methods from standard C, the component must be
              <code>@Singleton</code> functions is made possible.</para>
          <para>Use of global data as PRIVATE is made safe, which is useful when componentizing
            legacy C code.</para>
        </note>
      </simplesect>
      
      <simplesect>
        <title>Gains</title>
        
        <para>Used alone (not combined with over optimization annotations), <code>@Singleton</code>
          does not provide any benefit. Even, it increases the code section and the execution time,
          but using the <code>@Singleton</code> annotation is mandatory for some
          optimizations.</para>
      </simplesect>
      
      <simplesect>
        <title>Example</title>
        
        <para>The <code>@Singleton</code> annotation is described in the file
          <filename>optimisation/common/SingletonComponent.adl</filename></para>
        
        <para>The following code comes from the same application as the previous one.</para>
        
        <example>
          <title>The <code>@Singleton</code> annotation</title>
          
          <programlisting language="adl" linenumbering="unnumbered"><xi:include href="../../mindc-optimizations/src/assemble/resources/examples/optimisations/common/src/main/mind/common/SingletonComponent.adl" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>
        </example>
      </simplesect>
      
      <simplesect>
        <title>Tip : How to have binding optimization on a multi-instanciable component</title>
        
        <para>Since a multi-instanciable component is not <code>@Singleton</code>, it is not
          possible to apply the <code>@StaticBindings</code> annotation.</para>
        
        <para>In order to get around this problem, the following tip can be used : create an
          anonymous component with the <code>@Singleton</code> annotation that extends the
          multi-instanciable component. </para>
        
        <note><para>The component membrane and user code is duplicated. The gain is mainly for the call
            time.</para></note>
        
        <example>
          <title>Singletonization of a multi-instanciable component</title>
          
          <para>In this example the client component requires a collection of "MyItf" interface. To
            be able to optimize the bindings between this client to
              <code>MultiInstanciableComponent</code> using the <code>@Static</code> and
              <code>@StaticBindings</code> annotations, all instances of
              <code>MultiInstanciableComponent</code> must be singletonized.   </para>
          
          <programlisting language="adl" linenumbering="unnumbered">@StaticBindings
composite MainComposite {
	// Bindings
	binds clientComp.MyItf[0] to MultiInstanciableComp1.MyItf;
	binds clientComp.MyItf[1] to MultiInstanciableComp2.MyItf;
	binds clientComp.MyItf[2] to MultiInstanciableComp3.MyItf;
	binds clientComp.MyItf[3] to MultiInstanciableComp4.MyItf;
	
	// Contains
	contains clientComponent as clientComp;
	
	contains MultiInstanciableComponent as MultiInstanciableComp1 
	@Singleton primitive{};
	
	contains MultiInstanciableComponent as MultiInstanciableComp2 
	@Singleton primitive{};
	
	contains MultiInstanciableComponent as MultiInstanciableComp3 
	@Singleton primitive{};
	
	contains MultiInstanciableComponent as MultiInstanciableComp4 
	@Singleton primitive{};
}</programlisting>
        </example>
        
      </simplesect>
    </section>
    
    <section xml:id="optim-annot-garbagecomposite">
      <title>
        <code>@Flatten</code> (formerly <code>@GarbageComposite</code>) </title>
      
      <simplesect>
        <title>Annotation fields</title>
        <para>
          <command>@Flatten ( <replaceable>true</replaceable> | <replaceable>false</replaceable> )</command>
        </para>
        
        <para>This option allows to generate the result of the flattened ADL in the build output
          folder in files suffixed by <filename>_flat</filename>. By default, option is set to
            <code>false</code>.</para>
        <note>
          <para>When dumping flattened ADL, annotations are kept with a conservative approach during
            serialization. </para>
          <para>Use with caution: this feature is experimental.</para>
        </note>
      </simplesect>
      
      <simplesect>
        <title>Annotation targets</title>
        
        <para>
          <simplelist type="inline">
            <member>Composite definition</member>
          </simplelist>
        </para>
   
      
      <para>The <code>@Flatten</code> annotation removes all composites hierarchical levels. The
          final architecture is in the flattened view of all components. The top-level component
          resulting of the architecture transformation directly contains all the primitives and the
          "delegation bindings" (going through composites) are merged.</para>
      
      <note><para>The <code>--flatten</code> parameter of <command>mindc</command> compiler can be used to
            flatten a complete application.</para></note>
      
      <example>
        <title><code>@Flatten</code> overview</title>
        
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/AtGarbageComposite.png" format="PNG" width="80%"/>
          </imageobject>
        </mediaobject>
      </example>
      </simplesect>
      <simplesect>
        <title>Usage condition</title>
        
        <para>No condition.</para>
      </simplesect>
      
      <simplesect>
        <title>Consequences</title>
        
        <para>All optimization annotations applied on connections between
          several composite/primitive encapsulated in composites are
          suppressed.</para>
        
        <para><?oxy_comment_start author="SESA258801" timestamp="20141014T165448+0200" comment="Concrètement, c&apos;est quoi les risques ?"?>So
          be careful when this annotation is used in conjunction with <code>@Static</code> and
            <code>@StaticBindings</code> annotations.<?oxy_comment_end?></para>
      </simplesect>
      
      <simplesect>
        <title>Gains</title>
        
        <para>This annotation reduces the footprint and call time: Calls do not need to go through
          the membrane of composites.</para>
      </simplesect>
      
      <simplesect>
        <title>Example</title>
        
        <para>The <code>@flatten</code> annotation is described in the file
          <filename>optimisation/garbagecomposite/GarbagedCompositeApplication.adl</filename></para>
        
        <example>
          <title>The <code>@flatten</code> annotation</title>
          
          <programlisting language="adl" linenumbering="unnumbered"><xi:include href="../../mindc-optimizations/src/assemble/resources/examples/optimisations/garbage-composite/src/main/mind/garbagecomposite/GarbagedCompositeApplication.adl" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>
        </example>
      </simplesect>
    </section>    
    <section xml:id="optim-annot-GarbageUnusedInternal">
      <title>
        <code>@GarbageUnusedInternal</code>
      </title>
      
      <simplesect>
        <title>Note (March 2014)</title>
        
        <para>Since March 2014, this annotation will be OBSOLETE / DEPRECATED:
            <code>@GarbageUnusedInternal</code> is now always triggered.</para>
        
        <para>The annotation is ineffective and useless: it is strongly advised to remove it from
          your source code.</para>
      </simplesect>
      
      <simplesect>
        <title>Annotation fields</title>
        
        <para>
          <command>@GarbageUnusedInternal ( <replaceable>true</replaceable> |
              <replaceable>false</replaceable> )</command>
        </para>
        
        <para>This option allows to propagate the annotation in all sub-composites. By default,
          option is set to <code>false</code>.</para>
      </simplesect>
      
      <simplesect>
        <title>Annotation targets</title>
        
        <para>
          <simplelist type="inline">
            <member>Composite definition</member>
          </simplelist>
        </para>

      
      <para>The <code>@GarbageUnusedInternal</code> annotation removes residual generated code
          resulting of the usage of the <code>@StaticBindings</code> annotation.</para>
      
      <para>This annotation is used on composite definitions and removes unused code for composite
          and primitive definitions (optimal case removes the totality of the membrane code).</para>
      
      <example>
        <title><code>@GarbageUnusedInternal</code> overview</title>
        
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/AtGarbageUnusedInternal.png" format="PNG" width="80%"/>
          </imageobject>
        </mediaobject>
      </example>
      </simplesect>
      <simplesect>
        <title>Usage condition</title>
        
        <para>This annotation is the most efficient when collections are not used, client and
          controller interfaces are not bound in the composite.</para>
      </simplesect>
      
      <simplesect>
        <title>Consequences</title>
        
        <para>Detects all possible cases where <code>@StaticBindings</code> can generate empty
          structures. Compilers such as GCC tolerate those and reserve space in BSS section, however
          embedded compilers such as IAR completely forbid empty structures and stop compilation
          with an error, using <code>@GarbageUnusedInternal</code> allows avoiding this
          pitfall.</para>
      </simplesect>
      
      <simplesect>
        <title>Gains</title>
        
        <para>This annotation reduces the memory footprint (BSS section).</para>
 
      
      <example>
        <title>The <code>@GarbageUnusedInternal</code> annotation</title>
        
        <para>The <code>@GarbageUnusedInternal</code> annotation is used in conjunction with the
              <code>@StaticBindings</code> annotation.</para>
        
        <programlisting language="adl" linenumbering="unnumbered"><xi:include href="../../mindc-optimizations/src/assemble/resources/examples/optimisations/static-bindings/src/main/mind/staticbindings/StaticBindingsApplication.adl" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>
      </example>
      </simplesect>
    </section>
        
  </appendix>
</book>
