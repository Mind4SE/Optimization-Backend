<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section[
<!ENTITY % myents SYSTEM "../shared.ent" >
%myents;
]>
<section xml:id="Optimization-backend_gains" xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en">
  <title>Synthesis of gains</title>
  <table orient="land">
    <title>Gains per annotation</title>
    <tgroup cols="6" align="left">
      <colspec colnum="1" colname="c1" colwidth="100pt"/>
      <colspec colnum="2" colname="c2" colwidth="70pt"/>
      <colspec colnum="3" colname="c3" colwidth="155pt"/>
      <colspec colnum="4" colname="c4" colwidth="155pt"/>
      <colspec colnum="5" colname="c5" colwidth="155pt"/>
      <colspec colnum="6" colname="c6" colwidth="155pt"/>
      <thead>
        <row>
          <entry>Annotation</entry>
          <entry>Applies to</entry>
          <entry>Effect</entry>
          <entry>Memory (flash and RAM) gain</entry>
          <entry>Performance gain</entry>
          <entry>Flexibility loss</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry><code>@Static</code></entry>
          <entry>Binding between 2 singletons components</entry>
          <entry>Direct calls between required and provided interfaces</entry>
          <entry>
            <para>Flash : Remove size of the client interface vtable.</para>
            <para>RAM : Remove the "this" passed during the call (one pointer on the
              stack)</para>
          </entry>
          <entry>
            <para>Remove 2 indirections before the function call (remove some move instructions
              for each function call).</para>
            <para>Native compiler (GCC, IAR...) optimizations can also provide further
              improvements.</para>
          </entry>
          <entry>
            <para>Binding not re-configurable</para>
            <para>Components cannot be multi-instantiated</para>
          </entry>
        </row>
        <row>
          <entry>
            <code>@Static Bindings</code>
          </entry>
          <entry>Composite</entry>
          <entry>Apply <code>@Static</code> to all bindings of a composite</entry>
          <entry>
            <para>Same as above but for all bindings of a composite.</para>
            <para>Structures on both required and provided sides are removed.</para>
          </entry>
          <entry>
            <para>Remove indirections for all calls internal to the composite.</para>
          </entry>
          <entry>
            <para>Bindings in composite are not re-configurable</para>
            <para>Components in composite cannot be multi-instantiated</para>
          </entry>
        </row>
        <row>
          <entry>
            <code>@Static Definitions Bindings List</code>
          </entry>
          <entry>Composite</entry>
          <entry>At compilation time, freeze calls to an interface definition type</entry>
          <entry>
            <para>Flash : Remove some bytes dedicated to indirections</para>
            <para>RAM : no gain</para>
          </entry>
          <entry>
            <para>Remove 2 indirections before the function call</para>
          </entry>
          <entry>Re-binding can be done only on provided interface of the same type</entry>
        </row>
        <row>
          <entry>
            <code>@FreezeCall Pointer</code>
          </entry>
          <entry>Primitive</entry>
          <entry>At compilation time, freeze calls using CALL_PTR to an interface definition
            type</entry>
          <entry>
            <para>Same as above</para>
          </entry>
          <entry>
            <para>Same as above</para>
          </entry>
          <entry>Same as above</entry>
        </row>
      </tbody>
    </tgroup>
  </table>
  
  <para>The native C compilers (GCC, IAR...) can also provide several levels of optimizations on
    the code generated by the Mindc compiler using the &productName;.</para>
  <para>The experience shows that code optimized with the &productName; can be better optimized by
    the native C compiler (offsets computed, successive calls avoided...) than when compiling code
    generated with the default Mindc back-end.</para>
  <example>
    <title>Effects of optimization annotations</title>
    <para>The Mind <code>CALL(itf, fct)(args...)</code> is generated differently depending on the
      annotation used :</para>
    <para>
      <itemizedlist>
        <listitem>
          <para>Default generation : <code>this->type.itf->meths->fct(this, args ...)</code> is
            <emphasis role="bold">reconfigurable</emphasis> and applies to <emphasis role="bold">multi-instantiated components</emphasis></para>
        </listitem>
        <listitem>
          <para><code>@Singleton</code> : <code>this->type.itf.fct(args ...)</code> is <emphasis
            role="bold">reconfigurable</emphasis> and applies only to <emphasis role="bold"
              >singleton components</emphasis> (single instance)</para>
        </listitem>
        <listitem>
          <para><code>@StaticDefinitionsBindingsList</code> and <code>@FreezeCallPointer</code> :
            <code>fct(this, args ...)</code> is <emphasis role="bold">partially (same type only)
              reconfigurable</emphasis> and applies to <emphasis role="bold">multi-instantiated
                components</emphasis></para>
        </listitem>
        <listitem>
          <para><code>@Static</code> and <code>@StaticBindings</code> : <code>fct(args ...)</code>
            is <emphasis role="bold">not reconfigurable</emphasis> and applies only to <emphasis role="bold">singleton components</emphasis> (single instance)</para>
        </listitem>
      </itemizedlist>
    </para>
  </example>
</section>
