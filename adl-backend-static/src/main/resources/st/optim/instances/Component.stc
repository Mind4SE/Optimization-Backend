template st.optim.instances.Component : st.common.ComponentHelper
implements st.optim.instances.ComponentInstances{

st.optim.membrane.ControllerGenerator ctrlGenerator = plugin(st.optim.membrane);

$${

isClient ::= [ "client" : "true" ]
isServer ::= [ "server" : "true" ]

ComponentInstances(topLevelDefinition, definition, instances) ::= <<

/* Generated file: <topLevelDefinition;format="nameToPath">_<definition.name;format="toCName">_instances.c */

#include "<definition.name;format="nameToPath">.inc"

<if (definition.astNodeTypes.("source"))>
<if (definition.sources)>
#include "<definition.name;format="nameToPath">_impl.h"
<endif>
<endif>

<instances:IncludeDependencies(definition=definition, instance=it); separator="\n">

<instances:DeclareDependencies(definition=definition, instance=it); separator="\n">

<instances:DeclareInstance(definition=definition, instance=it); separator="\n\n">

<instances:InitInstance(definition=definition, instance=it); separator="\n\n">

<instances:DeclarePrivateData(definition=definition, instance=it); separator="\n\n">

<ConstructorCalls(definition=definition, instances=instances)>

>>

TopLevelInstances(topLevelDefinition, definitions, instances) ::= <<
<ComponentInstances(topLevelDefinition=topLevelDefinition, definition=topLevelDefinition, instances=instances)>

<InitCode(topLevelDefinition=topLevelDefinition, definitions=definitions)>

<if (!(first(instances).decorations.("allow-instance-data-removal")))>
void *__component_toplevel = &<first(instances).decorations.("instance-name"); format="toCName">;
<endif>
>>

IncludeDependencies(definition, instance) ::= <<
<definition.interfaces:IncludeServerHeader(definition=definition, instance=instance, interface=it);separator="\n">

<if (definition.astNodeTypes.("internalInterface"))>
<if (definition.internalInterfaces)>
<definition.interfaces:IncludeServerHeader(definition=definition, instance=instance, interface=it, isInternal="true");separator="\n">
<endif>
<endif>

<if (definition.astNodeTypes.("component"))>
<instance.subComponents:IncludeSubComponentHeader();separator="\n">
<endif>
>>

IncludeServerHeader(definition, instance, interface, isInternal) ::= <<
<if (interface.numberOfElement)>
<interface.astDecorations.("collectionIndexes"):{index |
<if (instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=interface.name, index=index, isInternal=isInternal)).serverComponent)>
#include "<instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=interface.name, index=index, isInternal=isInternal)).serverComponent.definition.name;format="nameToPath">.adl.h"
<endif>};separator="\n">
<else>
<if (instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=interface.name, isInternal=isInternal)).serverComponent)>
#include "<instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=interface.name, isInternal=isInternal)).serverComponent.definition.name;format="nameToPath">.adl.h"
<endif>
<endif>
>>

IncludeSubComponentHeader(subComponent) ::= <<
#include "<subComponent.definition.name;format="nameToPath">.adl.h"
>>

DeclareDependencies(definition, instance) ::= <<
<definition.interfaces:DeclareServerComponent(definition=definition, instance=instance, interface=it);separator="\n">
<if (definition.astNodeTypes.("internalInterface"))>
<if (definition.internalInterfaces)>
<definition.interfaces:DeclareServerComponent(definition=definition, instance=instance, interface=it, isInternal="true");separator="\n">
<endif>
<endif>
<if (definition.astNodeTypes.("component"))>
<instance.subComponents:DeclareSubComponent();separator="\n">
<endif>
>>

DeclareComponentInstance(instance) ::= <<
<if (!(instance.decorations.("allow-instance-data-removal")))>
#ifndef INSTANCE_<instance.decorations.("instance-name"); format="toCName">_DECLARED
<instance.definition.name;format="toUpperCName">_DECLARE_INSTANCE(<instance.decorations.("instance-name"); format="toCName">)
#define INSTANCE_<instance.decorations.("instance-name"); format="toCName">_DECLARED
#endif

<else>
/*
#ifndef INSTANCE_<instance.decorations.("instance-name"); format="toCName">_DECLARED
<instance.definition.name;format="toUpperCName">_DECLARE_INSTANCE(<instance.decorations.("instance-name"); format="toCName">)
#define INSTANCE_<instance.decorations.("instance-name"); format="toCName">_DECLARED
*/
<endif>

>>

DeclarePrivateData(definition, instance) ::= <<
<if (definition.astDecorations.("is-singleton"))>
<if (definition.astNodeTypes.("data"))>
<if (definition.data)>
/* Duplicate-definition fix for some families of compilers such as IAR */
#ifndef INSTANCE_<instance.decorations.("instance-name"); format="toCName">__PRIVATEDATA_DECLARED
<instance.definition.name;format="toUpperCName">_DECLARE_PRIVATEDATA(<instance.decorations.("instance-name"); format="toCName">_private_data)
#define INSTANCE_<instance.decorations.("instance-name"); format="toCName">_PRIVATEDATA_DECLARED
#endif
<endif>
<endif>
<endif>
>>

DeclareServerComponent(definition, instance, interface, isInternal) ::= <<
<if (interface.numberOfElement)>
<interface.astDecorations.("collectionIndexes"):{index |
<if (instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=interface.name, index=index, isInternal=isInternal)).serverComponent)>
<DeclareComponentInstance(instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=interface.name, index=index, isInternal=isInternal)).serverComponent)>
<endif>};separator="\n">
<else>
<if (instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=interface.name, isInternal=isInternal)).serverComponent)>
<DeclareComponentInstance(instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=interface.name, isInternal=isInternal)).serverComponent)>
<endif>
<endif>
>>

DeclareSubComponent(subComponent) ::= <<
<DeclareComponentInstance(subComponent)>
>>

DeclareInstance(definition, instance) ::= <<
<DeclareComponentInstance(instance)>
>>

InitInstance(definition, instance) ::= <<
<DefineAttributeValues(definition=definition, instance=instance)>

<! SSZ : BEGIN MODIFICATION !>
<if (!(instance.decorations.("allow-instance-data-removal")))>
<definition.name;format="toUpperCName">_INIT_INSTANCE(<instance.decorations.("instance-name"); format="toCName"> 
  <AddItfValues(definition=definition, instance=instance)>
  <AddSubComponentValues(definition=definition, instance=instance)>
  <AddAttributeValues(definition=definition, instance=instance)>
  <AddControllersValues(definition=definition, instance=instance)>
)

// Start StaticBindings Collection optimization
<AddSBCollectionItfValues(definition=definition, instance=instance)>
// End StaticBindings Collection optimization
<endif>
<! SSZ : END MODIFICATION !>
>>

AddItfValues(definition, instance) ::= <<
<definition.interfaces:AddItfValue(definition=definition, instance=instance, itf=it)>
<if (definition.astNodeTypes.("internalInterface"))>
<if (definition.internalInterfaces)>
<definition.internalInterfaces:AddItfValue(definition=definition, instance=instance, itf=it, isInternal="true")>
<endif>
<endif>

>>

AddItfValue(definition, instance, itf, isInternal) ::= <<
<if (isClient.(itf.role))>
<if (itf.numberOfElement)>
<itf.astDecorations.("collectionIndexes"):AddItfCollectionValue(definition=definition, instance=instance, itf=itf, index=it, isInternal=isInternal);separator="\n">
<else>
, /* <itf.name> */ <BindingCastIfNeeded(instance=instance, itf=itf, isInternal=isInternal)><StaticBindingValue(bindingDesc=instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, isInternal=isInternal)))>
<endif>
<endif>
>>

AddItfCollectionValue(definition, instance, itf, index, isInternal) ::= <<
<if (instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, index=index, isInternal=isInternal)))>
, /* <itf.name>[<index>] */ <CollectionBindingCastIfNeeded(instance=instance, itf=itf, index=index, isInternal=isInternal)><StaticBindingValue(bindingDesc=instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, index=index, isInternal=isInternal)))>
<else>
, /* <itf.name>[<index>] */ <CollectionBindingCastIfNeeded(instance=instance, itf=itf, index=index, isInternal=isInternal)><StaticCollectionBindingValue(bindingDesc=instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, isInternal=isInternal)), index=index)>
<endif>
>>

StaticBindingValue(bindingDesc) ::= <<
<if (bindingDesc.binding)>
<! SSZ : BEGIN MODIFICATION !>
<! Optimization when Binding is static means that some structures won't exist, so don't even mention them, replace by 0,0,0 !>
<if (!bindingDesc.binding.astDecorations.("is-static"))>
<! SSZ : END MODIFICATION !>
&(<bindingDesc.serverComponent.decorations.("instance-name"); format="toCName">.__component_internal_data.<if (bindingDesc.toInternalServer)>inner_type<else>type<endif>.<bindingDesc.binding.toInterface><if (bindingDesc.binding.toInterfaceNumber)>[<bindingDesc.binding.toInterfaceNumber>]<endif>), 
&(<bindingDesc.serverComponent.decorations.("instance-name"); format="toCName">), 
&__component_<bindingDesc.serverComponent.definition.name; format="toCName">_<bindingDesc.binding.toInterface><if (bindingDesc.binding.toInterfaceNumber)>_<bindingDesc.binding.toInterfaceNumber><endif>_VTable
<! SSZ : BEGIN MODIFICATION !>
<else>
0, 0, 0
<endif>
<! SSZ : END MODIFICATION !>
<else>
0, 0, 0
<endif> 

>>

StaticCollectionBindingValue(bindingDesc, index) ::= <<
<if (bindingDesc.binding)>
&(<bindingDesc.serverComponent.decorations.("instance-name"); format="toCName">.__component_internal_data.<if (bindingDesc.toInternalServer)>inner_type<else>type<endif>.<bindingDesc.binding.toInterface>[<index>]), 
&(<bindingDesc.serverComponent.decorations.("instance-name"); format="toCName">),
&__component_<bindingDesc.serverComponent.definition.name; format="toCName">_<bindingDesc.binding.toInterface>_<index>_VTable
<else>
0, 0, 0
<endif> 
>>

StaticBindingItfName(itfName, index, isInternal) ::= "<if (isInternal)>INTERNAL_<endif><itfName><if (index)>_<index><endif>"

BindingCastIfNeeded(instance, itf, isInternal) ::= << <if (instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, isInternal=isInternal)).binding.astDecorations.("type-inheritance-cast"))>(<instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, isInternal=isInternal)).binding.astDecorations.("type-inheritance-cast"); format="toCName">)<endif> >>
CollectionBindingCastIfNeeded(instance, itf, index, isInternal) ::= << <if (instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, index=index, isInternal=isInternal)).binding.astDecorations.("type-inheritance-cast"))>(<instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, index=index, isInternal=isInternal)).binding.astDecorations.("type-inheritance-cast"); format="toCName">)<endif> >>

AddSBCollectionItfValues(definition, instance) ::= <<
<definition.interfaces:AddSBCollectionItfValue(definition=definition, instance=instance, itf=it)>
<if (definition.astNodeTypes.("internalInterface"))>
<if (definition.internalInterfaces)>
<definition.internalInterfaces:AddSBCollectionItfValue(definition=definition, instance=instance, itf=it, isInternal="true")>
<endif>
<endif>

>>

AddSBCollectionItfValue(definition, instance, itf, isInternal) ::= <<
<if (isClient.(itf.role))>
<if (itf.numberOfElement)>
<if (definition.astDecorations.("parent-has-static-bindings"))>
<if (itf.astDecorations.("interfaceDefinition"))>
// <itf.name> client interface
<itf.astDecorations.("interfaceDefinition").methods:{<AddSBItfCollectionValue(definition=definition, instance=instance, itf=itf, method=it, isInternal=isInternal)>}; separator="\n">
<endif>
<endif>
<endif>
<endif>
>>

AddSBItfCollectionValue(definition, instance, itf, method, isInternal) ::= <<
<itf.astDecorations.("collectionIndexes"):{<AddSBCollectionTargetFunctionPrototype1(definition=definition, instance=instance, itf=itf, index=it, isInternal=isInternal, methName=method.name)>}; separator="\n">
<definition.name;format="toUpperCName">_<itf.name;format="toUpperCName">_<method.name;format="toUpperCName">_INIT_COLL_FNCPTR_ARRAY(__component_<definition.name; format="toCName">_<itf.name;format="toCName">_<method.name;format="toCName">, <itf.astDecorations.("collectionIndexes"):{<AddSBBindingValue(definition=definition, instance=instance, itf=itf, index=it, isInternal=isInternal, methName=method.name)>}; separator=",\n">)

>>

AddSBBindingValue(definition, instance, itf, index, isInternal, methName) ::= <<
<if (instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, index=index, isInternal=isInternal)))>
<AddFuncPtrValue(definition=definition, instance=instance, itf=itf, index=index, isInternal=isInternal, bindingDesc=instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, index=index, isInternal=isInternal)), methName=methName)>
<else>
0
<endif>
>>

AddFuncPtrValue(definition, instance, itf, index, isInternal, bindingDesc, methName) ::= <<
<if (bindingDesc.binding)>
__component_<bindingDesc.serverComponent.definition.name; format="toCName">_<bindingDesc.binding.toInterface><if (bindingDesc.binding.toInterfaceNumber)>_<bindingDesc.binding.toInterfaceNumber><endif>_<methName>
<else>
0
<endif>
>>

AddSBCollectionTargetFunctionPrototype1(definition, instance, itf, index, isInternal, methName) ::= <<
<if (instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, index=index, isInternal=isInternal)))>
<AddSBCollectionTargetFunctionPrototype2(definition=definition, instance=instance, itf=itf, index=index, isInternal=isInternal, bindingDesc=instance.decorations.("binding-descriptors").(StaticBindingItfName(itfName=itf.name, index=index, isInternal=isInternal)), methName=methName)>
<endif>
>>

AddSBCollectionTargetFunctionPrototype2(definition, instance, itf, index, isInternal, bindingDesc, methName) ::= <<
<if (bindingDesc.binding)>
extern <methodDef(method=method, methodName=FuncPointerTypeName(bindingDesc=bindingDesc, methName=methName), withThisPtr="false")>;
<endif>
>>

FuncPointerTypeName(bindingDesc, methName) ::= "__component_<bindingDesc.serverComponent.definition.name; format=\"toCName\">_<bindingDesc.binding.toInterface><if (bindingDesc.binding.toInterfaceNumber)>_<bindingDesc.binding.toInterfaceNumber><endif>_<methName>"
// End StaticBindings Collection optimization

DefineAttributeValues(definition, instance) ::= <<
<if (definition.astNodeTypes.("attribute"))>
<definition.attributes:DefineAttributeValue(definition=definition, instance=instance, attribute=it);separator="\n">
<endif>
>>

DefineAttributeValue(definition, instance, attribute) ::= <<
<if (instance.decorations.("attribute-values").(attribute.name))>
#define <instance.decorations.("instance-name"); format="toUpperCName">_<attribute.name; format="toUpperCName"> <instance.decorations.("attribute-values").(attribute.name)>
<endif>
>>

AddAttributeValues(definition, instance) ::= <<
<if (definition.astNodeTypes.("attribute"))>
<definition.attributes:AddAttributeValue(definition=definition, instance=instance, attribute=it);separator="\n">
<endif>
>>

AddAttributeValue(definition, instance, attribute) ::= <<
<if (instance.decorations.("attribute-values").(attribute.name))>
, /* <attribute.name> */ <instance.decorations.("instance-name"); format="toUpperCName">_<attribute.name; format="toUpperCName">
<endif>
>>

AddSubComponentValues(definition, instance) ::= <<
<if (definition.astNodeTypes.("component"))>
<instance.subComponents:AddSubComponentValue(definition=definition, instance=instance, subComponent=it);separator="\n">
<endif>
>>

AddSubComponentValue(definition, instance, subComponent) ::= <<
<! SSZ : BEGIN MODIFICATION !><if (!(subComponent.decorations.("allow-instance-data-removal")))>, <subComponent.decorations.("instance-name"); format="toCName"><else>/*, <subComponent.decorations.("instance-name"); format="toCName">*/<endif><! SSZ : END MODIFICATION !>
>>

AddControllersValues(definition, instance) ::= <<
<if (definition.astNodeTypes.("controller"))>
<definition.controllers:AddControllerValues(definition=definition, ctrl=it, instance=instance)>
<endif>
>>

AddControllerValues(definition, ctrl, instance) ::= <<
<ctrl.sources:{<(ctrlGenerator.(it.path).ControllerDataNamedInit)(definition=definition, controller=ctrl, instance=instance)>}>
>>


ConstructorCalls(definition, instances) ::= <<
#ifdef CONSTRUCTOR_METHOD_IMPLEMENTED
<if (definition.astDecorations.("is-singleton"))>
  void __component_<definition.name;format="toCName">_constructor(void);
<else>
  void __component_<definition.name;format="toCName">_constructor(<ComponentTypeName(definitionName=definition.name)>  *instance);
<endif>

#endif

#define <definition.name;format="toUpperCName">_CONSTRUCTOR_CALLS_DECLARED
void __component_<definition.name;format="toCName">_constructor_calls(void) {
#ifdef CONSTRUCTOR_METHOD_IMPLEMENTED
  <instances:ConstructorCall(definition=definition, instance=it); separator="\n">
#endif
}

#ifdef DESTRUCTOR_METHOD_IMPLEMENTED
<if (definition.astDecorations.("is-singleton"))>
  void __component_<definition.name;format="toCName">_destructor(void);
<else>
  void __component_<definition.name;format="toCName">_destructor(<ComponentTypeName(definitionName=definition.name)> *instance);
<endif>

#endif

#define <definition.name;format="toUpperCName">_DESTRUCTOR_CALLS_DECLARED
void __component_<definition.name;format="toCName">_destructor_calls(void) {
#ifdef DESTRUCTOR_METHOD_IMPLEMENTED
  <instances:DestructorCall(definition=definition, instance=it); separator="\n">
#endif
}
>> 

ConstructorCall(definition, instance) ::= <<
<if (definition.astDecorations.("is-singleton"))>
  __component_<definition.name;format="toCName">_constructor();
<else>
  __component_<definition.name;format="toCName">_constructor(& <instance.decorations.("instance-name"); format="toCName">);
<endif>
>>

DestructorCall(definition, instance) ::= <<
<if (definition.astDecorations.("is-singleton"))>
  __component_<definition.name;format="toCName">_destructor();
<else>
  __component_<definition.name;format="toCName">_destructor(& <instance.decorations.("instance-name"); format="toCName">);
<endif>
>>

InitCode(topLevelDefinition, definitions) ::= <<
  <definitions:DeclareConstructorCalls(definition=it);separator="\n">
  
  void __component_global_init(void) {
    <definitions:{__component_<it.name;format="toCName">_constructor_calls();};separator="\n">
  }
  
  <definitions:DeclareDestructorCalls(definition=it);separator="\n">
  
  void __component_global_shutdown(void) {
    <definitions:{__component_<it.name;format="toCName">_destructor_calls();};separator="\n">
  }

>>

DeclareConstructorCalls(definition) ::= <<
#ifndef <definition.name;format="toUpperCName">_CONSTRUCTOR_CALLS_DECLARED
#define <definition.name;format="toUpperCName">_CONSTRUCTOR_CALLS_DECLARED
void __component_<it.name;format="toCName">_constructor_calls(void);
#endif
>>

DeclareDestructorCalls(definition) ::= <<
#ifndef <definition.name;format="toUpperCName">_DESTRUCTOR_CALLS_DECLARED
#define <definition.name;format="toUpperCName">_DESTRUCTOR_CALLS_DECLARED
void __component_<it.name;format="toCName">_destructor_calls(void);
#endif
>>

// -----------------------------------------------------------------------------
// Nearly brutally copied from IDL2C/IDL2CPP since we need to define function pointers arrays

// we took inspiration from methodPointerDef to create methodPointersArrayDef

methodDef(method, methodName, withThisPtr) ::= <<
<typeQualifier(qualifiers=method)><varDef(type=method.type, name=methodPrototype(name=methodName, parameters=method.parameters, withThisPtr=withThisPtr, vaArgs=method.vaArgs))>
>>

methodPointerCast(method, withThisPtr) ::= <<
(<varDef(type=method.type, name=methodPrototype(name="(*)", parameters=method.parameters, withThisPtr=withThisPtr, vaArgs=method.vaArgs))>)
>>


methodPointerDef(method, withThisPtr) ::= "<methodDef(method=method, methodName=methodPointerName(name=method.name), withThisPtr=withThisPtr)> "

methodPointerName(name) ::= "(* <name>)"

// Arrays
methodPointersArrayDef(definition, method, itf, withThisPtr) ::= "<methodDef(method=method, methodName=methodPointersArrayName(definition=definition, name=method.name, itf=itf), withThisPtr=withThisPtr)> "

methodPointersArrayName(definition, name, itf) ::= "(* __component_<definition.name;format=\"toCName\">_<itf.name>_<name>[<itf.numberOfElement>])"
//

thisPointerDef ::= [
  "true" : "void *_mind_this",
  "typed" : "CONTEXT_PTR_DECL",
  "false" : ""
]

thisPointerComma ::= [
  "true" : ",",
  "typed" : ",",
  "false" : ""
]

noParamVoid ::= [
  "true" : "",
  "typed" : "",
  "false" : "void"
]

vaArgsMap ::= [
   "true" : "true",
   default :
]

methodPrototype(name, parameters, withThisPtr, vaArgs) ::= <<
<name>(<thisPointerDef.(withThisPtr)> <if(parameters)>
<thisPointerComma.(withThisPtr)> <parameters:parameterDef(parameter=it); separator=", "> <if (vaArgs)>, ...<endif>
<else> 
<if (vaArgs)> <thisPointerComma.(withThisPtr)> ...
<else>
<noParamVoid.(withThisPtr)> 
<endif>
<endif>)
>>

parameterDef(parameter) ::= <<
<typeQualifier(qualifiers=parameter)><varDef(type=parameter.type, name=parameterName(parameter=parameter))>
>>

parameterName(parameter) ::= <<
<if (parameter.isOut)>
<outParameterTemplateMap.(parameter.isOut)>
<else>
<outParameterTemplateMap.false>
<endif>
>>

outParameterTemplateMap ::= [
  "true"  : "(*<parameter.name>)",
  "false" : "<parameter.name>",
  default : "<parameter.name>"
]

enumRefDef(type) ::= "enum <type.name>"

varDef(type, name) ::= <<
<(varDefTemplateMap.(type.astDecorations.kind))(type=type, name=name)>
>>

enumVarDef(type, name) ::= "<enumDef(type=type)> <name>"

enumRefVarDef(type, name) ::= "<enumRefDef(type=type)> <name>"

structVarDef(type, name) ::= "<structDef(type=type)> <name>"

structRefVarDef(type, name) ::= "<structRefDef(type=type)> <name>"

unionVarDef(type, name) ::= "<unionDef(type=type)> <name>"

unionRefVarDef(type, name) ::= "<unionRefDef(type=type)> <name>"

pointerOfVarDef(type, name) ::= "<varDef(type=type.type, name=pointerOfVarName(type=type, name=name))>"

pointerOfVarName(type, name) ::= "(* <typeQualifier(qualifiers=type)><name>)"

arrayOfVarDef(type, name) ::= "<varDef(type=type.type, name=arrayOfVarName(type=type, name=name))>"

arrayOfVarName(type, name) ::= "<name>[<if (type.constantExpression)><expression(expr=type.constantExpression)><endif>]"

simpleVarDef(type, name) ::= <<
<if (primitiveTypeNameMap.(type.name))>
<primitiveTypeNameMap.(type.name)> <name>
<else>
<type.name> <name>
<endif>
>>

typedefVarDef(type, name) ::= <<
<type.name; format="toCName"> <name>
>>

varDefTemplateMap ::= [
  "enum" :          "enumVarDef",
  "enumRef" :       "enumRefVarDef",
  "struct" :        "structVarDef",
  "structRef" :     "structRefVarDef",
  "union" :         "unionVarDef",
  "unionRef" :      "unionRefVarDef",
  "pointerOf" :     "pointerOfVarDef",
  "arrayOf" :       "arrayOfVarDef",
  "primitiveType" : "simpleVarDef",
  "typedefRef" :    "typedefVarDef"
]

primitiveTypeNameMap ::= [
  "string" : "__MIND_STRING_TYPEDEF"
]

expression(expr) ::= <<
<(constantExpressionTemplateMap.(expr.astDecorations.kind))(expr=expr)>
>>

binaryOpertaionExpr(expr) ::= <<
<expr.constantExpressions:{(<expression(expr=it)>)};separator=expr.operation>
>>

unaryOperationExpr(expr) ::= <<
<expr.operation> (<expression(expr=expr.constantExpression)>)
>>

castOperationExpr(expr) ::= <<
((<varDef(type=expr.type, name="")>) <expression(expr=expr.constantExpression)>)
>>

literalExpr(expr) ::= <<
<expr.expr>
>>

constantExpressionTemplateMap ::= [
  "binaryOperation" : "binaryOpertaionExpr",
  "unaryOperation" :  "unaryOperationExpr",
  "castOperation" :   "castOperationExpr",
  "literal" :         "literalExpr"
]

typeQualifier(qualifiers) ::= <<
<constQualiferMap.(qualifiers.isConst)><volatileQualifierMap.(qualifiers.isVolatile)>
>>

constQualiferMap ::= [
  "true" : "const ",
  "false": ""
]

volatileQualifierMap ::= [
  "true" : "volatile ",
  "false": ""
]

isVoidMethod(method) ::= "<(voidTypeTemplateMap.(method.type.astDecorations.kind))(type=method.type)>"

voidPrimitiveType(type) ::= "<isVoidMap.(type.name)>"

voidComplexType(type) ::= "<isComplexTypeVoidMap.(type)>"

voidTypeTemplateMap ::= [
  "primitiveType" : "voidPrimitiveType",
  default         : "voidComplexType"
]

isVoidMap ::= [ "void" : "true" ]
isComplexTypeVoidMap ::= [ default : ]

}$$

}